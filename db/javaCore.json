[
  {
    "question": "Чем различаются JRE, JVM и JDK?",
    "answer": "JVM, Java Virtual Machine (Виртуальная машина Java) — основная часть среды времени исполнения\n\nJava (JRE). Виртуальная машина Java исполняет байт-код Java, предварительно созданный из \nисходного текста Java-программы компилятором Java. JVM может также использоваться для выполнения\nпрограмм, написанных на других языках программирования.\n\nJRE, Java Runtime Environment (Среда времени выполнения Java) - минимально-необходимая реа-\nлизация виртуальной машины для исполнения Java-приложений. Состоит из JVM и стандартного\nнабора библиотек классов Java.\n\nJDK, Java Development Kit (Комплект разработки на Java) - JRE и набор инструментов разработчика\nприложений на языке Java, включающий в себя компилятор Java, стандартные библиотеки классов\nJava, примеры, документацию, различные утилиты.\nКоротко: JDK - среда для разработки программ на Java, включающая в себя JRE - среду для \nобеспечения запуска Java программ, которая в свою очередь содержит JVM - интерпретатор кода Java\nпрограмм.",
    "category": "JavaCore",
    "id": 1
  },
  {
    "question": "Какие существуют модификаторы доступа?",
    "answer": "private (приватный): члены класса доступны только внутри класса. Для обозначения используется\nслужебное слово private.\n\ndefault, package-private, package level (доступ на уровне пакета): видимость класса/членов класса\nтолько внутри пакета. Является модификатором доступа по умолчанию - специальное обозначение\nне требуется.\n\nprotected (защищённый): члены класса доступны внутри пакета и в наследниках. Для обозначения\nиспользуется служебное слово protected.\n\npublic (публичный): класс/члены класса доступны всем. Для обозначения используется служебное\nслово public.",
    "category": "JavaCore",
    "id": 2
  },
  {
    "question": "О чем говорит ключевое слово final?",
    "answer": "- Класс не может иметь наследников;\n- Метод не может быть переопределен в классах наследниках;\n- Поле не может изменить свое значение после инициализации;\n- Параметры методов не могут изменять своё значение внутри метода;\n- Локальные переменные не могут быть изменены после присвоения им значения.",
    "category": "JavaCore",
    "id": 3
  },
  {
    "question": "Что такое тернарный оператор выбора?",
    "answer": "Тернарный условный оператор ?: - оператор, которым можно заменить некоторые конструкции\nоператоров if-then-else.\nВыражение записывается в следующей форме:\nусловие ? выражение1 : выражение2\n\nЕсли условие выполняется, то вычисляется выражение1 и его результат становится результатом\nвыполнения всего оператора. Если же условие равно false, то вычисляется выражение2 и его \nзначение становится результатом работы оператора. Оба операнда выражение1 и выражение2 должны\nвозвращать значение одинакового (или совместимого) типа.",
    "category": "JavaCore",
    "id": 4
  },
  {
  "question": "Чем абстрактный класс отличается от интерфейса?\nВ каких случаях следует использовать абстрактный\nкласс, а в каких интерфейс?",
  "answer": "В Java класс может одновременно реализовать несколько интерфейсов, но наследоваться только\nот одного класса.\nАбстрактные классы используются только тогда, когда присутствует тип отношений «is a» (явля-\nется). Интерфейсы могут реализоваться классами, которые не связаны друг с другом.\nАбстрактный класс - средство, позволяющее избежать написания повторяющегося кода, инстру-\nмент для частичной реализации поведения. Интерфейс - это средство выражения семантики клас-\nса, контракт, описывающий возможности. Все методы интерфейса неявно объявляются как public\nabstract или (начиная с Java 8) default - методами с реализацией по-умолчанию, а поля - public static\nfinal.\nИнтерфейсы позволяют создавать структуры типов без иерархии.\nНаследуясь от абстрактного, класс «растворяет» собственную индивидуальность. \nРеализуя интерфейс, он расширяет собственную функциональность.\n\nАбстрактные классы содержат частичную реализацию, которая дополняется или расширяется в\nподклассах. При этом все подклассы схожи между собой в части реализации, унаследованной от \nабстрактного класса и отличаются лишь в части собственной реализации абстрактных методов \nродителя. Поэтому абстрактные классы применяются в случае построения иерархии однотипных, очень\nпохожих друг на друга классов. В этом случае наследование от абстрактного класса, реализующего\nповедение объекта по умолчанию может быть полезно, так как позволяет избежать написания \nповторяющегося кода. Во всех остальных случаях лучше использовать интерфейсы.",
  "category": "JavaCore",
  "id": 5
},
  {
    "question": "Каков порядок вызова конструкторов и блоков \nинициализации с учётом иерархии классов?",
    "answer": "Сначала вызываются все статические блоки в очередности от первого статического блока корневого\nпредка и выше по цепочке иерархии до статических блоков самого класса.\nЗатем вызываются нестатические блоки инициализации корневого предка, конструктор корневого\nпредка и так далее вплоть до нестатических блоков и конструктора самого класса.",
    "category": "JavaCore",
    "id":6
  },
  {
    "question": "Какие типы классов бывают в java?",
    "answer": "- Top level class (Обычный класс):\nAbstract class (Абстрактный класс);\nFinal class (Финализированный класс).\n- Interfaces (Интерфейс).\n- Enum (Перечисление).\n- Nested class (Вложенный класс):\nStatic nested class (Статический вложенный класс);\nMember inner class (Простой внутренний класс);\nLocal inner class (Локальный класс);\nAnonymous inner class (Анонимный класс).",
    "category": "JavaCore",
    "id": 7
  },
  {
    "question": "В чем разница между членом экземпляра класса и \nстатическим членом класса?",
    "answer": "Модификатор static говорит о том, что данный метод или поле принадлежат самому классу и доступ\nк ним возможен даже без создания экземпляра класса. Поля, помеченные static инициализируются\nпри инициализации класса. На методы, объявленные как static, накладывается ряд ограничений:\nОни могут вызывать только другие статические методы.\nОни должны осуществлять доступ только к статическим переменным.\nОни не могут ссылаться на члены типа this или super.\nВ отличии от статических, поля экземпляра класса принадлежат конкретному объекту и могут\nиметь разные значения для каждого. Вызов метода экземпляра возможен только после \nпредварительного создания объекта класса.",
    "category": "JavaCore",
    "id": 8
  },
  {
    "question": "Что такое Heap и Stack память в Java?\nКакая разница между ними?",
    "answer": "Heap (куча) используется Java Runtime для выделения памяти под объекты и классы. Создание \nнового объекта также происходит в куче. Это же является областью работы сборщика мусора. \nЛюбой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться из любой части\nприложения.\nStack (стек) это область хранения данных также находящееся в общей оперативной памяти (RAM).\nВсякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит \nпримитивы и ссылки на другие объекты в методе. Как только метод заканчивает работу, блок также \nперестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой\nпамяти намного меньше объема памяти в куче. Стек в Java работает по схеме \nLIFO (Последний-зашел-Первый-вышел)\nРазличия между Heap и Stack памятью:\nКуча используется всеми частями приложения в то время как стек используется только одним\nпотоком исполнения программы.\nВсякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится лишь\nссылка на него. Память стека содержит только локальные переменные примитивных типов и \nссылки на объекты в куче.",
    "category": "JavaCore",
    "id": 9
  },
  {
    "question": "Чем отличаются final, finally и finalize()?",
    "answer": "Модификатор final:\n- Класс не может иметь наследников;\n- Метод не может быть переопределен в классах наследниках;\n- Поле не может изменить свое значение после инициализации;\n- Локальные переменные не могут быть изменены после присвоения им значения;\n- Параметры методов не могут изменять своё значение внутри метода.\nОператор finally гарантирует, что определенный в нём участок кода будет выполнен независимо от\nтого, какие исключения были возбуждены и перехвачены в блоке try-catch.\nМетод finalize() вызывается перед тем как сборщик мусора будет проводить удаление объекта.",
    "category": "JavaCore",
    "id": 10
  },
  {
    "question": "Что такое класс Object? Какие в нем есть методы?",
    "answer": "Object это базовый класс для всех остальных объектов в Java. Любой класс наследуется от Object и,\nсоответственно, наследуют его методы:\npublic boolean equals(Object obj) – служит для сравнения объектов по значению; \nint hashCode() –возвращает hash код для объекта; \nString toString() – возвращает строковое представление объекта;\nClass getClass() – возвращает класс объекта во время выполнения; \nprotected Object clone() – создает и возвращает копию объекта;",
    "category": "JavaCore",
    "id": 11
  },
  {
    "question": "Зачем нужен equals().\nЧем он отличается от операции ==?",
    "answer": "Метод equals() - определяет отношение эквивалентности объектов.\nПри сравнении объектов с помощью == сравнение происходит лишь между ссылками. \nПри сравнении по переопределённому разработчиком equals() - по внутреннему состоянию объектов.",
    "category": "JavaCore",
    "id": 12
  },
  {
    "question": "Какая связь между hashCode() и equals()?",
    "answer": "Равные объекты должны возвращать одинаковые хэш коды. При переопределении equals() нужно\nобязательно переопределять и метод hashCode().\n- если хэш коды разные, то и объекты гарантированно разные;\n- если хэш коды равны, то объекты могут не обязательно равны.",
    "category": "JavaCore",
    "id": 13
  }

]