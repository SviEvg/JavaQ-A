[
  {
    "question": "Назовите основные интерфейсы и их реализации",
    "answer": "Java Collection Framework располагаются 2 интерфейса: Collection и Map.\nЭти интерфейсы разделяют все коллекции, входящие во фреймворк на две части по типу хранения\nданных: простые последовательные наборы элементов и наборы пар «ключ — значение» соответ-\nственно.\nИнтерфейс Collection расширяют интерфейсы:\n- List (список) представляет собой коллекцию, в которой допустимы дублирующие значения.\nЭлементы такой коллекции пронумерованы, начиная от нуля, к ним можно обратиться по индексу.\nРеализации:\nArrayList - инкапсулирует в себе обычный массив, длина которого автоматически увеличивает-\nся при добавлении новых элементов.\nLinkedList (двунаправленный связный список) - состоит из узлов, каждый из которых содержит\nкак собственно данные, так и две ссылки на следующий и предыдущий узел.\nVector — реализация динамического массива объектов, методы которой синхронизированы.\nStack — реализация стека LIFO (last-in-first-out).\n- Set (сет) описывает неупорядоченную коллекцию, не содержащую повторяющихся элементов.\nРеализации:\nHashSet - использует HashMap для хранения данных. В качестве ключа и значения используется\nдобавляемый элемент. Из-за особенностей реализации порядок элементов не гарантируется при\nдобавлении.\nLinkedHashSet — гарантирует, что порядок элементов при обходе коллекции будет идентичен\nпорядку добавления элементов.\nTreeSet — предоставляет возможность управлять порядком элементов в коллекции при помощи\nобъекта Comparator, либо сохраняет элементы с использованием «natural ordering».\n- Queue (очередь) предназначена для хранения элементов с предопределённым способом вставки\nи извлечения FIFO (first-in-first-out):\nPriorityQueue — предоставляет возможность управлять порядком элементов в коллекции при\nпомощи объекта Comparator, либо сохраняет элементы с использованием «natural ordering».\nArrayDeque — реализация интерфейса Deque, который расширяет интерфейс Queue методами,\nпозволяющими реализовать конструкцию вида LIFO (last-in-first-out).\nИнтерфейс Map реализован классами:\nHashtable — хэш-таблица, методы которой синхронизированы. Не позволяет использовать null в\nкачестве значения или ключа и не является упорядоченной.\nHashMap — хэш-таблица. Позволяет использовать null в качестве значения или ключа и не явля-\nется упорядоченной.\nLinkedHashMap — упорядоченная реализация хэш-таблицы.\nTreeMap — реализация, основанная на красно-чёрных деревьях. Является упорядоченной и\nпредоставляет возможность управлять порядком элементов в коллекции при помощи объекта\nComparator, либо сохраняет элементы с использованием «natural ordering».",
    "category": "Collections",
    "id": 1
  },
  {
    "question": "Чем различаются Enumeration и Iterator?",
    "answer": "Оба интерфейса и предназначены для обхода коллекций между ними имеются существенные\nразличия:\n- с помощью Enumeration нельзя добавлять/удалять элементы;\n- в Iterator исправлены имена методов для повышения читаемости кода (Enumeration.\nhasMoreElements() соответствует Iterator.hasNext(), Enumeration.nextElement() соответствует Iterator.\nnext() и т.д);\n- Enumeration присутствуют в устаревших классах, таких как Vector/Stack, тогда как Iterator есть\nво всех современных классах-коллекциях.",
    "category": "Collections",
    "id": 2
  },
  {
    "question": "Как устроен HashMap?",
    "answer": "HashMap состоит из «корзин» (bucket). С технической точки зрения «корзины» — это элементы\nмассива, которые хранят ссылки на списки элементов. При добавлении новой пары «ключ-значе-\nние», вычисляет хэш-код ключа, на основании которого вычисляется номер корзины (номер ячейки\nмассива), в которую попадет новый элемент. Если корзина пустая, то в нее сохраняется ссылка на\nвновь добавляемый элемент, если же там уже есть элемент, то происходит последовательный пере-\nход по ссылкам между элементами в цепочке, в поисках последнего элемента, от которого и ставит-\nся ссылка на вновь добавленный элемент. Если в списке был найден элемент с таким же ключом, то\nон заменяется.",
    "category": "Collections",
    "id": 3
  },
  {
    "question": "В чем отличия TreeSet и HashSet?",
    "answer": "TreeSet обеспечивает упорядоченно хранение элементов в виде красно-черного дерева. Сложность\nвыполнения основных операций не хуже O(log(N)) (Логарифмическое время).\nHashSet использует для хранения элементов такой же подход, что и HashMap, за тем отличием, что\nв HashSet в качестве ключа и значения выступает сам элемент, кроме того HashSet не поддерживает\nупорядоченное хранение элементов и обеспечивает временную сложность выполнения операций\nаналогично HashMap.",
    "category": "Collections",
    "id": 4
  }


]